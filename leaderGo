极客时间 陈皓(左耳听风) :https://coolshell.cn/

jdk6引入serviceProvider

-->   概念上更接近实现方组织上位于实现方所在的包中实现和接口在一个包中

-->当接口属于调用方时，我们就将其称为spi，全称为：service provider interface，spi的规则如下：
    概念上更依赖调用方组织上位于调用方所在的包中实现位于独立的包中（也可认为在提供方中）
    ServiceLoader可以通过service provider的配置文件来装载指定的service provider。当服务的提供者，提供了服务接口的一种实现之后，
    我们只需要在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。
    而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。
-->DriverManager初始化时也运用了spi的思想，使用ServiceLoader把写到配置文件里的Driver都加载了进来。
   我们打开mysql-connector-java的jar包，果然在META-INF/services下发现了上文中提到的接口路径，打开里面的内容，
   可以看到是com.mysql.jdbc.Driver

jvm tomcat 类加载：
    -->tomcat下catalina.properties common.loader ->https://zhuanlan.zhihu.com/p/24168200

linux:nohub 后台执行 ./mqnamesr


Netty:基于JDK中Future的基础上，添加异步监听等方法，反映了Netty事件驱动的本质
    ChannelFuture extends Future<>,Promise extends Future  https://www.kancloud.cn/ssj234/netty-source/433211     

        
java内存分布:https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247484884&amp;idx=1&amp;sn=0d9b841ce0fc300c78ade2a87ffbfb46&source=41#wechat_redirect

javap是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。

linux调优:uptime - top(3秒) - pidstat - perf top (perf record记录) - vmstat - iostat 
      -->模拟压测(并发调用，多次):apachebench - sysbench - webbench - http_load - siege
